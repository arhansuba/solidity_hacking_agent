# vulnerability_forecasting_model.py

import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from datetime import datetime
import matplotlib.pyplot as plt

class LSTMModel(nn.Module):
    def __init__(self, input_size, hidden_size, num_layers, output_size):
        super(LSTMModel, self).__init__()
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        out, _ = self.lstm(x, (h0, c0))
        out = self.fc(out[:, -1, :])
        return out

class VulnerabilityForecastingModel:
    def __init__(self, input_size, hidden_size, num_layers, output_size, learning_rate=0.001):
        self.model = LSTMModel(input_size, hidden_size, num_layers, output_size).to(torch.device('cuda' if torch.cuda.is_available() else 'cpu'))
        self.criterion = nn.MSELoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=learning_rate)
        self.scaler = MinMaxScaler()

    def preprocess_data(self, data, sequence_length):
        data = self.scaler.fit_transform(data)
        X, y = [], []
        for i in range(len(data) - sequence_length):
            X.append(data[i:i+sequence_length])
            y.append(data[i+sequence_length])
        return np.array(X), np.array(y)

    def train(self, train_data, sequence_length, epochs=100):
        X_train, y_train = self.preprocess_data(train_data, sequence_length)
        X_train = torch.tensor(X_train, dtype=torch.float32)
        y_train = torch.tensor(y_train, dtype=torch.float32)

        for epoch in range(epochs):
            self.model.train()
            outputs = self.model(X_train)
            loss = self.criterion(outputs.squeeze(), y_train)
            self.optimizer.zero_grad()
            loss.backward()
            self.optimizer.step()

            if (epoch+1) % 10 == 0:
                print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}')

    def forecast(self, input_data, sequence_length, forecast_steps):
        self.model.eval()
        with torch.no_grad():
            input_data = self.scaler.transform(input_data)
            X = [input_data[-sequence_length:]]
            X = torch.tensor(X, dtype=torch.float32)
            forecasts = []

            for _ in range(forecast_steps):
                pred = self.model(X).cpu().numpy()
                forecasts.append(pred[0])
                X = np.append(X[:, 1:, :], np.expand_dims(pred, 1), axis=1)
                X = torch.tensor(X, dtype=torch.float32)

            return self.scaler.inverse_transform(np.array(forecasts).reshape(-1, 1)).flatten()

# Example usage
if __name__ == "__main__":
    # Example data
    date_range = pd.date_range(start='2023-01-01', periods=365, freq='D')
    vulnerabilities = np.sin(np.linspace(0, 10, 365)) + np.random.normal(0, 0.1, 365)  # Mock data

    # Prepare data
    data = pd.DataFrame({'date': date_range, 'vulnerabilities': vulnerabilities})
    forecasting_model = VulnerabilityForecastingModel(input_size=1, hidden_size=50, num_layers=2, output_size=1)

    # Train the model
    forecasting_model.train(data['vulnerabilities'].values.reshape(-1, 1), sequence_length=30, epochs=100)

    # Forecast future vulnerabilities
    future_steps = 30
    forecast = forecasting_model.forecast(data['vulnerabilities'].values.reshape(-1, 1), sequence_length=30, forecast_steps=future_steps)

    # Plot results
    plt.figure(figsize=(12, 6))
    plt.plot(date_range, vulnerabilities, label='Historical Data')
    future_dates = pd.date_range(start=date_range[-1] + pd.Timedelta(days=1), periods=future_steps)
    plt.plot(future_dates, forecast, label='Forecast', color='red')
    plt.xlabel('Date')
    plt.ylabel('Vulnerabilities')
    plt.title('Vulnerability Forecasting')
    plt.legend()
    plt.show()
